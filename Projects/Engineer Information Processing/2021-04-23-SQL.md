---
title: SQL 최적화 및 성능 튜닝    
tag: 정처기  
---

# 옵티마이저  
사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할을 수행한다. (= Execution Plan)  

## 규칙기반 옵티마이저  

- 우선 순위를 가지고 실행계획을 생성함  
- 우선순위 대로 중요한 규칙은 다음과 같음.  

1. Single row by rowid  
  rowid를 통해 하나의 행을 엑세스하는 방식(1컬럼을 엑세스하는 것 중 가장 빠른 방법). 
2. Single row by unique or primary key  
3. Composite index  
4. Single column index  
5. Bounded range search on indexed columns  
6. UnBounded range search on indexed columns  
7. Full table scan  

## 비용기반 옵티마이저  

위의 규칙기반 옵티마이저를 좀더 최적화 한 방식. SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선턱하는 방식  
테이블, 인덱스, 칼럼 등의 당야한 객체 통계정보와 시스템 통계 정보를 이용하므로 정확한 통계정보를 유지하는 것은 비용기반 최적화에 중요한 요소이다.  

---  

# 옵티마이저의 실행계획  

어떤 순서로 SQL문을 실행할지 결정하는 작업.  
액세스 기법은 하나의 테이블을 액세스 할때 인덱스 스캔을 할지 전체테이블 스캔을 할지에 대한 계획이고 최적화 정보는 실행계획의 각 단계마다 예상되는 비용 사항을 표시한 것.  

# SQL처리 흐름도  

내부적인 처리 절차를 시각적으로 표현한 도표  

# Index  

INSERT, UPDATE, DELETE 등과 같은 DML 작업은 테이블과 함께 인덱스를 변경해야 하기 때문에 느려질 수도 있다. 따라서 테이블의 성격을 분석해야 하며 앞에서 언급한 명령어가 많을 경우 인덱스를 사용하지 않는 편이 나을 수 있다.  

## 종류  

밀집 인덱스, 희소 인덱스, B+트리 인덱스, 클러스터드 인덱스 등등  

## 인덱스를 사용하기 좋은 좋건  

1. 기본키와 외래키에 인덱스를 생성하면 좋다.  
  - 식별자로 자주 접근 (빠르고 자주 접근)  
  - 레코드 삽입 시 기본키 중복 검사가 쉽다.  
  - 2개의 테이블을 JOIN 할 경우 FK를 가지고 있는 테이블에 레코드를 검색하기 좋다.  
2. 대용량 테이블에서 일부분을 검색하는 경우가 많을 때  
3. 인덱스를 적용한 칼럼의 도메인이 다양할 때  
  - 레코드가 여러 그룹으로 분할되어 검색 효율이 좋아지기 때문이다.  
4. 칼럼이 정수형 일 때  

## 인덱스를 사용하기 나쁜 조건  

1. UPDATE가 빈번한 속성의 경우  
2. INSERT가 빈번한 테이블의 경우  
3. 속성의 도메인이 단순할 경우 
4. VARCHAR, INTEGER, DATE의 속성일 경우  
5. 데이터가 적을 경우(어느 정도?)  
6. 대량의 데이터를 삽입할 경우 인덱스를 삭제한 후에 진행  

## 인덱스의 크기  

탐색키에 해당하는 속성만을 갖기 때문에 실제 테이블 크기의 10~20%정도의 크기를 갖음  

## 트리 기반 인덱스  

> B-Tree Index (DMBS에서 가장 일반적으로 사용됨)     

![](https://qwefgh90.github.io/sphinx/_images/B-TREE2.JPG)  

- Root Block ( Index node)  
- Branch Block( Index node)  
  Key, next(pointer)  
- Leaf Block, 데이터 노드 (이하 리프 블록)  
리프 블록은 인덱스를 구성하는 칼럼의 키와 해당 데이터의 위치를 가르키는 레코드 식별자로 구성되어 있다. 인덱스 데이터는 인덱스를 구성하는 칼럼의 값으로 정렬된다.  

### 값을 찾는 과정(양뱡향 링크드 리스트)  

![](https://qwefgh90.github.io/sphinx/_images/B-TREE.gif)  

1. 브랜치 블록의 가자 ㅇ왼쪽 값이 찾고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동  
2. 찾고자 하는 값이 브랜치 블록의 값 사이에 존재하면 가운데 포인터로 이동  
3. 오른쪽에 있는 값보다 크면 오른쪽 포인터로 이동  
4. 리프노드에 도달하게 되면 (Key value, rowid) 쌍을 찾는다.  

---  
## 클러스터형 인덱스  

- 리프 페이지 = 데이터 페이지  
  레코드 식별자(테이블 탐색에 필요한) 불필요  
- 리프 페이지의 모든 데이터는 인덱스 키 칼럼 순으로 정렬되어 저장된다.(물리적으로)  

## 클러스터드 인덱스  

순차 파일을 유지 && 하나의 컬럼을 정렬의 기준으로 설정, 데이터 노드에는 블록의 첫번째 주소를 가르키게 함. -> 인접한 데이터 조회, 범위 질의에 유용 (물리적 디스크에서 가깝게 저장되기때문에)  


[참고](https://qwefgh90.github.io/sphinx/database/sql_optimize.html)  

