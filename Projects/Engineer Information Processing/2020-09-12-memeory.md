---
title: 메모리 기법
tag: 정처기
---



## 스와핑

- dispatcher
- 문맥교환 시간 증가
  - 최적화 방법으로 해결

## 연속 메모리 할당

미리 분석, 덩어리 할당

간단함

할당, 제어 반복 ->비어 있는 부분이 생김, 찾아서 할당해야할 필요성이 있음.

### 동적 메모리 할당

- Frist-fit
- Best-fit
- Worts-fit

메모리의 자투리, 메모리의 빈 공간들



## 단편화

fragmentation

- 외부 단편화
  - 최조 할당 메모리
  - 성능 상 심각한 문제임.
- 해결방법
  - 메모리 압축
    - 분산된 자유 공간을 모아서 큰 블록은 생성
    - 메모리 위치를 옮겨줘야함. 효율적이지 않음
  - paging과 segmentation
    - 할당 할때 덩어리를(주소 공간을) 분할하여 비연속적인 물리메모리 공간에 할당

- 내부 단편화

> 미리 할당되는 덩어리들 때문에 생기는 문제임.



## 페이징

- 페이지
- 주소를 정확히 알고 있어야 실행가능
- 연속된 메모리 공간으로 인식해야함.
- 논리 주소, 물리 주소의 구분과 상호작용
  - 주소의 동적 재배치를 허용해야함.(나뉘어져 있는 것을 하나로 인식시켜야함.)
  - 주소 변환 시 필요한 전용 하드웨어 (MMU)



### Paging

- Frame
  - 물리 메모리의 고정 크기 블록
- Page
  - 논리 메모리의 고정 크기 블록(프레임과 같은 크기)



### 페이징의 주소 표현

- 페이지 테이블
  - 각 페이지에 대한 base 주소 역할
    - 메모리의 프레임 번호 제공



### MMU

- 페이지 테이블 크기가 일정하고 큰 편.(모든 페이지들의 주소를 포함해서)



### 페이징의 특징

- 효과적인 메모리 관리 기법
- 실제 메모리 할당을 고려하지 않아도 되서 좋음. (사용자, 프로세스 둘다 좋음)
- 외부 단편화가 없음.(페이지 안에서 단편화가 생길 수도 있음)
- 페이지 크기를 작게하면 내부 단편화가 감소하지만 페이지 테이블 크기가 증가

- 프레임 테이블(역방향으로 추적함. 메모리-> 페이지)
- 페이징과 문맥 교환
- 공유 페이지



### 페이지 테이블의 구현

- 페이지 테이블도 메모리에 저장
  - 기준 레지스터
    - 메모리에 저장된 페이지 테이블의 시작 주소를 저장
    - 페이지 테이블은 array임. 주소를 바로 알 수 있음.
    - 주소 변환 없음. 문맥교환 시 페이지 테이블 교체 비용이 작음
- 메모리 접근 시간 문제
  - 매번 메모리의 페이지 테이블을 먼저 읽어야해서 메모리 접근 시간이 두배가 됨.

- 해결책

  - 페이지 테이블의 caching

    ​	Translation Look-aside Buffer : 저장장소

#### TLB

- 페이지 테이블을 위한 소형의 하드웨어 캐시
- 페이지 테이블 일부 저장. 번호와 값을 쌍으로 . 
- 검색, 전부 비교함. 케시의 특성

