---
title: const, static
tag: cpp
---





[모두의 코드](https://modoocode.com/197)

---

## initializer list, 생성자의 초기화 리스트

생성자 호출과 동시에 멤버 변수들을 초기화해주게 됩니다.

```cpp
(생성자 이름) : var1(arg1), var2(arg2) {} //일반적인 형식
```

여기서 `var` 들은 클래스의 멤버 변수들을 지칭하고, `arg` 는 그 멤버 변수들을 무엇으로 초기화 할 지 지칭하는 역할을 합니다. 한 가지 흥미로운 점은 `var1` 과 `arg1` 의 이름이 같아도 됩니다.

> 초기화 리스트를 사용한 버전의 경우 **생성과 초기화를 동시에** 하게 됩니다.

---

## static 변수

전역 변수의 경우 프로젝트의 크기가 커질 수 록 프로그래머의 실수로 인해 서로 겹쳐서 오류가 날 가능성이 다분하기에 반드시 필요한 경우가 아니면 사용을 하지 않습니다. (실제로 꼭 필요한 경우가 아니면 전역변수는 사용하지 맙시다)

 전역 변수 같지만 클래스 하나에만 종속되는 변수인 것인데요, 바로 `static` 멤버 변수입니다.

```cpp
static int total_marine_num;	//정의
int Marine::total_marine_num = 0; 	//초기화
```

```cpp
class Marine {
  static int total_marine_num = 0; 
//static은 클래스 내부에서 이런 형태로 초기화 불가능, 애당초 메모리 할당하기 전에 값이 존재하기 때문에?
    
class Marine {
  const static int x = 0;
//const 변수는 가능
```

+ 함수

`static` 함수의 경우, 객체가 없어도 그냥 클래스 자체에서 호출할 수 있게 됩니다. 

```
(클래스)::(static 함수)
```

 형식으로 호출하게 됩니다. 왜냐하면 어떠한 객체도 이 함수를 소유하고 있지 않기 때문이죠. 그러하기에, `static` 함수 내에서는 클래스의 `static` 변수 만을 이용할 수 밖에 없습니다.

만일 `static` 함수 내에서 아래처럼 그냥 클래스의 멤버 변수들을 이용한다면 변수가 어디서 왔는지 모름. 왜냐하면 앞에서 계속 말해왔듯이 어떤 객체에도 속해이지 않기 때문이니까요!

---

## this

 자기 자신을 가리키는 포인터 this

객체 자신을 가리키는 포인터의 역할을 합니다. 즉, 이 멤버 함수를 호출하는 객체 자신을 가리킨다는 것이지요.

---

## 레퍼런스를 리턴하는 함수

## const 함수

변수들의 값을 바꾸지 않고 읽기 만 하는, 마치 상수 같은멤버 함수를 '상수 함수' 로써 선언할 수 있습니다.

```cpp
(기존의 함수의 정의) const;
```

 우리는 상수 함수로 이 함수를 정의함으로써, 이 함수는 다른 변수의 값을 바꾸지 않는 함수라고 다른 프로그래머에게 명시 시킬 수 있습니다. 당연하게도, 상수 함수 내에서는 객체들의 '읽기' 만이 수행되며, 상수 함수 내에서 호출 할 수 있는 함수로는 다른 상수 함수 밖에 없습니다.