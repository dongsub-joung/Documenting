---
title: copy constructor, destructor
tag: cpp
---



# [destructor, copy constructor](https://modoocode.com/188)

## 소멸자

우리가 생성했던 객체가 소멸 될 때 자동으로 호출되는 함수 - 마치 객체가 생성될 때 자동으로 호출 되었던 생성자 처럼 소멸 될 때 자동으로 호출되는 함수가 있다면 얼마나 좋을까요? 놀랍게도 이미 C++ 에서는 이 기능을 지원하고 있습니다. 바로 **소멸자(Destructor)** 이죠

생성자가 클래스 이름과 똑같이 생겼다면 소멸자는 그 앞에 `~` 만 붙여주시면 됩니다.

ex)

```cpp
Marine::~Marine() {
  std::cout << name << " 의 소멸자 호출 ! " << std::endl;
  if (name != NULL) {
    delete[] name;
  }
}
```

 '객체가 파괴될 때 호출되는 소멸자' 를 확실하게 확인할 수 있었을 것입니다.

소멸자가 하는 가장 흔한 역할은 위에서도 나타나 있지만, 객체가 동적으로 할당받은 메모리를 해제하는 일이라고 볼 수 있습니다. 그 외에도 (아직 배우진 않았지만) 쓰레드 사이에서 `lock` 된 것을 푸는 역할이라던지 등의 역할을 수행하게 됩니다.

참고로 우리가 따로 생성자를 정의하지 않더라도 디폴트 생성자가 있었던 것 처럼, 소멸자도 **디폴트 소멸자(Default Destructor)**가 있습니다. 물론, 디폴트 소멸자 내부에선 아무런 작업도 수행하지 않습니다. 만일 소멸자가 필요 없는 클래스라면 굳이 소멸자를 따로 써줄 필요는 없습니다.

---

## 복사 생성자

```
T(const T& a);
```

 다른 `T` 의 객체 `a` 를 상수 레퍼런스로 받는 다는 이야기 입니다. 여기서 `a` 가 `const` 이기 때문에 우리는 복사 생성자 내부에서 `a` 의 데이터를 변경할 수 없고, 오직 새롭게 초기화 되는 인스턴스 변수들에게 '복사' 만 할 수 있게 됩니다. 

```cpp
Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc) {
  std::cout << "복사 생성자 호출 !" << std::endl;
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;
}
```

```cpp
pc.coord_x = 3;
```

복사 생성자 내부에서 `pc` 의 인스턴스 변수들에 접근해서 객체의 `shield, coord_x, coord_y` 등을 초기화 할 수 는 있지만 `pc` 의 값 자체는 변경할 수 없다는 이야기 입니다.

> 인자로 받는 변수의 내용을 함수 내부에서 바꾸지 않는다면 앞에 `const` 를 붙여 주는 것이 바람직합니다.

```
Photon_Cannon pc3 = pc2; //Photon_Cannon pc3(pc2);
```

생성 시에 대입하는 연산, 즉 위에 같이 `Photon_Cannon pc3 = pc2;` 한다면, 복사 생성자가 호출되게 되는 것입니다. 이런식으로 `Photon_Cannon pc3 = pc2;` 를 해석함으로써 사용자가 상당히 직관적이고 깔끔한 프로그래밍을 할 수 있습니다.

# 

# 

```cpp
Photon_Cannon pc3 = pc2;
// 복사 생성자가 1 번 호출되는 것
```

```cpp
Photon_Cannon pc3;
pc3 = pc2;
// 생성자가 1 번 호출되고, pc3 = pc2; 라는 명령이 실행되는 것
```

는 엄연히 다른 문장입니다. 왜냐하면 위의 것은 말 그대로 복사 생성자가 1 번 호출되는 것이고, 아래 것은 그냥 생성자가 1 번 호출되고, `pc3 = pc2;` 라는 명령이 실행되는 것이지요. 다시 한 번 강조하지만, 복사 생성자는 오직 '생성' 시에 호출된다는 것을 명심하시면 됩니다.

C++ 컴파일러는 이미 **디폴트 복사 생성자(Default copy constructor)** 를 지원해 주고 있습니다. 

디폴트 복사 생성자의 경우 기존의 디폴트 생성자와 소멸자가 하는 일이 아무 것도 없었던 것과는 달리 실제로 '복사' 를 해줍니다.

대응되는 원소들을 말 그대로 1 대 1 복사해주게 됩니다. 따라서 위와 같이 간단한 클래스의 경우 귀찮게 복사생성자를 써주지 않고도 디폴트 복사 생성자만 이용해서 복사 생성을 쉽게 처리할 수 있습니다.

---

### 디폴트 복사 생성자의 한계

이미 해제된 메모리에 접근해서 다시 해제하려고 하였기 때문에 (사실 접근한 것 자체만으로 오류) 위 그림과 같이 무서운 런타임 오류가 발생하게 됩니다. 그렇다면 이러한 문제를 막으로면 어떡할까요?

 복사 생성자에서 `name` 을 그대로 복사하지 말고 따로 다른 메모리에 동적 할당을 해서 그 내용만 복사하면 되겠지요?이렇게 메모리를 새로 할당해서 내용을 복사하는 것을 **깊은 복사(deep copy)** 라고 부르며 아까 처럼 단순히 대입 만 해주는 것을 **얕은 복사(shallow copy)** 라고 부릅니다. 컴파일러가 생성하는 디폴트 복사 생성자의 경우 얕은 복사 밖에 할 수 없으므로 위와 같이 깊은 복사가 필요한 경우에는 사용자가 직접 복사 생성자를 만들어야 합니다.

---

