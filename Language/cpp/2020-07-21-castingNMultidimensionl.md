---
title: Casting, C String, C-style string symbolic constants
tag: cpp
---



## C++ 스타일의 캐스팅

- `static_cast` : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
- `const_cast` : 객체의 상수성(const) 를 없애는 타입 변환. 쉽게 말해 `const int` 가 `int` 로 바뀐다.
- `dynamic_cast` : 파생 클래스 사이에서의 다운 캐스팅 (→ 정확한 의미는 나중에 다시 배울 것입니다)
- `reinterpret_cast` : 위험을 감수하고 하는 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등

---

### 방법

```
(원하는 캐스팅 종류)<바꾸려는 타입>(무엇을 바꿀 것인가?)
```

우리가 만들어야 할 배열은 정해진 상수 차원의 배열이 아니라, `N` 차원의 배열이라는 뜻입니다. 만일 3 차원 배열을 만들었다면 `int***` 을 이용하였을 것이고 4 차원 배열은 `int ****` 을 이용하였을 터인데 (물론 불편하기는 하지만, 쉽게 생각하자면 말입니다.) `N` 차원 배열의 경우 `N` 개의 `*` 들이 들어간 포인터를 정의할 수 없는 터입니다.

---

[Casting: 씹어먹는 C++](https://modoocode.com/204)

---


## C style String

`cin.getline()`을 호출하면 최대 254자를 `name`으로 읽을 수 있다. 초과한 문자는 버려진다. 이러한 방법으로 오버플로를 하지 않도록 보장한다!

`strcpy()`를 사용하면 문자열을 다른 문자열로 복사할 수 있다. 일반적으로 문자열에 값을 할당하는 데 사용한다.

C++ 11에서는 `strcpy()` 대신 `strcpy_s`를 사용할 수 있으며, 새로운 매개 변수가 추가되어 대상의 크기를 정의할 수 있습니다.

또 다른 유용한 함수는 C 스타일 문자열의 길이를 반환하는 `strlen()` 함수다. (null 종결자는 제외한 길이다.)

`strcat()` : 한 문자열을 다른 문자열에 추가한다.

`strncat()` : 버퍼 길이 검사를 통해 하나의 문자열을 다른 문자열에 추가한다.

`strcmp()` : 두 문자열을 비교한다. (같은 경우 0 반환)

`strncmp()` : 두 문자열을 지정된 문자 수만큼 비교한다. (같은 경우 0 반환)

> std::string

---

[정리: 소년코딩](https://boycoding.tistory.com/198?category=1009770)

---

## 문자열 기호 상수



```cpp
#include <iostream>

int main()
{
    //고정 배열
    char myName[] = "Alex";
    std::cout << myName;

    return 0;
}
```

C++은 또한 포인터를 사용해서 C 스타일 문자열 기호 상수를 만드는 방법도 지원한다.

```cpp
#include <iostream>

int main()
{
    //포인터
    const char *myName = "Alex";
    std::cout << myName;

    return 0;
}
```

> 위의 두 프로그램은 같은 결과를 생성하고 운영하지만, C++은 이들 프로그램에 대한 <u>메모리 할당을 약간 다르게 한다.</u>

고정 배열의 경우 프로그램은 길이가 5인 고정 배열에 메모리를 할당하고 "Alex\0" 문자열로 해당 메모리를 초기화한다.

배열에 대해 메모리가 구체적으로 할당되었으므로 배열의 내용을 자유롭게 변경할 수 있다. 

배열 자체는 일반 지역 변수로 처리되므로 배열이 범위를 벗어나면 배열에서 사용하는 메모리가 다른 용도로 사용할 수 있다.

+ 기호 상수의 경우, 컴파일러가 이를 어떻게 처리하는지 구현에 따라 정의된다. 

일반적으로 컴파일러는 문자열 "Alex\0"을 <u>읽기 전용 메모리 어딘가에 배치한 다음 가리키는 포인터를 설정한다.</u> 

<u>이 메모리는 읽기 전용이므로 문자열이 const인지 확인하는 것이 좋다.</u>

---

최적화를 위해 여러 문자열을 리터럴을 단일 값으로 통합할 수 있다.

```cpp
const char* name1 = "Alex";
const char* name2 = "Alex"
```

값이 같은 두 개의 다른 문자열 리터럴이다. 

컴파일러는 <u>이들을 단일 공유 문자열 리터럴로 결합할 수 있으며, `name1`과 `name2`는 같은 주소를 가리킨다.</u> 

따라서, `name1`이 const가 아닌 경우 `name1`을 변경하면 `name2`에 영향을 줄 수 있다.

---

또한, 이 방법으로 선언된 문자열은 프로그램 수명 내내 지속되므로 범위(scope) 지정 문제에 대해 걱정할 필요가 없다.

```cpp
const char* getName()
{
    return "Alex";
}
```

위의 코드에서 `getName()`은 C 스타일 문자열 "Alex"에 대한 포인터를 반환한다. 

`getName()`이 종료될 때 "Alex"는 범위를 벗어나지 않으므로 호출자가 계속 성공적으로 접근할 수 있다.

> 요약하면 나중에 수정할 수 있는 문자열 변수가 필요한 경우 문자 배열을 사용하자. 
>
> 읽기 전용 문자열 리터럴이 필요한 경우에는 문자열 리터럴에 대한 const 포인터를 사용하자.



### std::cout and char pointers

비문자 포인터(non-char pointer)를 포인터의 내용(포인터가 보유하고 있는 주소)을 출력한다. 

그러나 char* 또는 const char* 유형의 객체를 전달하면 문자열을 출력한다고 가정한다. 

결과적으로, 포인터의 값을 출력하는 대신에 지시된 문자열을 출력한다.

---

 [정리: 소년코딩](https://boycoding.tistory.com/203?category=1009770)

---




