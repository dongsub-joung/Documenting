---
title: Nested Structure
tag: cpp
---



## 중첩 구조체

### C

중첩 구조체란 다른 구조체를 멤버로 포함하는 구조체이다. 구조체의 멤버가 될 수 있는 타입에는 제한이 없으므로 구조체도 다른 구조체의 멤버가 될 수 있다.

구조체는 하나의 복잡한 실체에 대한 정보들을 저장하는데 이 정보들이 좀 더 큰 정보의 일부가 되는 경우는 아주 흔하다. 

구조체를 아무리 중첩시킨다고 해도 포함관계에 따라 멤버 연산자만 적절히 사용하면 중첩된 구조체의 멤버도 얼마든지 참조할 수 있다. C는 구조체끼리의 중첩에 대해 별다른 제한을 두지 않으므로 여러 겹으로 구조체를 중첩시키는 것이 가능하다. 

```C
#include <Turboc.h>

void main()
{
     // 회원 한 명의 신상
     struct tag_Friend 
     {
          char Name[10];          // 이름
          int Age;                  // 나이
          double Height;             // 키
     };
 
     // 동아리에 대한 정보
     struct tag_Circle 
     {
          char Name[16];          // 동아리 이름
          int MemNum;                   // 회원수
          tag_Friend Member[50];    // 회원 목록
     };

     // 동아리 목록
     tag_Circle arCircle[10];
 
     // 동아리 목록을 가리키는 포인터
     tag_Circle *pCircle;
     pCircle=arCircle;

     // 4번째 동아리의 3번째 회원 나이
     arCircle[4].Member[3].Age=21;
    
     // pCircle이 가리키는 동아리의 3번째 회원의 나이
     pCircle->Member[3].Age=22;

     // pCircel이 가리키는 동아리의 3번째 회원의 이름 중 2번째 문자
     pCircle->Member[3].Name[2]='M';
}
```



[정리: soen.kr](http://soen.kr/lecture/ccpp/cpp1/13-2-4.htm)

---

### C++ 구조체의 확장

 밀접한 구조체와 함수는 한 쌍으로 볼 수 있는데 C++은 연관된 코드와 데이터를 하나의 범위에 포함시킬 수 있는 방법을 제공한다. 이 개념이 바로 캡슐화이다. 구조체가 다양한 타입의 멤버 변수를 포함하듯이 함수도 포함할 수 있다. 

```cpp
#include <Turboc.h>

struct Position
{
     int x;
     int y;
     char ch;
    
     void OutPosition()
     {
          gotoxy(x, y);
          putch(ch);
     }
};

void main()
{
     Position Here; //초기화
     Here.x=30;
     Here.y=10;
     Here.ch='A';
     Here.OutPosition();
}
```

구조체와 관련된 함수를 따로 정의할 필요없이 아예 구조체에 포함시켜 버린 것이다. 

C++에서 구조체는 멤버 변수와 멤버 함수로 구성된다. 

C의 구조체는 이형 변수의 집합, 즉 타입이 다른 변수들의 집합이다. 변수만 포함될 수 있었으므로 단순히 멤버라는 용어를 사용했지만 C++의 구조체에는 함수도 같이 포함될 수 있으므로 두 종류의 멤버를 구분할 수 있는 별도의 이름이 필요해진 것이다. 

다른 언어에서는 멤버 변수를 필드(Field), 멤버 함수를 메소드(Method)라고 부르기도 하는데 같은 뜻이다. //자바

#### 함수를 구조체 안에 포함하면 좋은 점

+ 구조체에 소속되었기 때문에 소속된 구조체의 정보를 사용할 수 있다.

구조체에 포함된 함수는 독립된 함수가 아니라 구조체에 속한 멤버이므로 어떤 구조체의 정보를 대상으로 동작할 것인지를 밝혀야 한다. 

멤버 함수를 호출하는 방법은 멤버 변수를 참조하는 것과 동일하다. 점 연산자를 사용하여 구조체.함수() 식으로 호출하며 구조체 포인터라면 구조체->함수() 식으로 호출한다.

구조체가 멤버 함수를 포함하면 스스로 동작할 수 있는 독립성이 부여된다. 멤버 변수로 정보를 기억할 수 있고 이 정보들을 바탕으로 직접 동작도 할 수 있다. 

독립성이 생기면 재사용성이 확보된다. 내부에 정보와 함수를 모두 포함하고 있으므로 이 구조체만 다른 프로젝트로 가져가면 쉽게 재사용할 수 있다.

>  이것이 바로 OOP 캡슐화의 기본적인 개념이다. 변수든 함수든 논리적으로 관련된 것을 한 곳에 모아 묶어 놓음으로써 구조체가 프로그램의 부품 역할을 할 수 있게 된 것이다.



[정리: soen.kr](http://www.soen.kr/lecture/ccpp/cpp3/25-3-1.htm)

---