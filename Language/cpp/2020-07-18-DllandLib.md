---
title: 외부 라이브러리(dll,lib) 사용하기
tag: cpp
---





[KimJunHee의 글](https://wnsgml972.github.io/setting/2018/11/01/dll_lib/)

---

Library: 외부의 코드를 사용하기 위한 것.

+ `dll`은 동적 라이브러리, Runtime에 필요

+ `lib`은 정적 라이브러리, compile할 때 필요

---

## lib

### Link  단계에서 정적으로 라이브러리 파일을 추가합니다.

일반적으로 실행 파일을 만들 때는 소스 코드를 컴파일하고 만들어진 obj 파일을 링커가 하나로 묶어 exe 파일을 만듭니다. 여기서 `lib`을 사용하면 링크 단계에서 링커가 이 `lib`파일도 같이 묶어서 하나의 exe 파일을 만들게 됩니다.

**쉽게 말하면 우리가 컴파일에 성공해 만들어지는 exe 파일 안에 lib의 내용이 모두 들어가게 됩니다.**

우리가 일반적으로 쓰는 `stdio.h` 같은 코드 덩어리도 실제 선언한 곳에 전부 들어가 있게 됩니다. 그렇기 때문에 많이 쓰이면 쓰일수록 파일이 무거워지게 되며, RAM에 메모리가 많이 올라가게 됩니다.

> [링커](https://jhnyang.tistory.com/40)

---

### 미리 컴파일된 헤더 pch와의 차이는?

`pch`는 말 그대로 전처리기가 헤더 파일의 내용을 가져와서 컴파일러가 그 내용을 컴파일하지만, `lib`은 이미 컴파일된 obj 파일을 가지고 링커가 연결만 시켜줍니다.

또한 `pch`는 사용하고자 하는 곳에 모두 명시를 해야 하지만, `lib`은 하지 않아도 괜찮습니다. 

다만 아까 말했듯이 많이 사용한다면 파일의 크기가 커지는 단점이 있습니다. -> **(이러한 단점을 해결하기 위해 dll이 나왔습니다.)**

---

### 적용

`lib`을 만들고 해당 소스를 외부의 다른 프로젝트에서 사용하려면 필요한 것은 2가지가 있습니다.

1. 링커에게 해당 `lib`의 경로를 알려준다.
2. 해당 `include(header)`의 경로를 알려준다

---

## dll

- Link 단계에서 **동적으로** 라이브러리 파일을 추가합니다. //메모리 절약

`dll`은  파일을 실행할 때 해당 링커가 `dll`의 위치를 알고 있다면 exe 파일에 내용이 포함되어 있지 않아도 실행이 가능합니다.

> **즉 동적인 링킹이 가능합니다.** (`dll`은 프로세스의 주소 공간에 동적으로 로드가 가능하게 만들어져있기 때문입니다.)

---

### 	링킹 방법

`dll`은 프로세스의 주소 공간에 로드 되어야만 사용될 수 있다.

- 암시적 링킹

  **실행 파일 자체**에 어떤 `dll`의 어떤 함수를 사용하겠다는 정보를 포함시키고 운영체제가 프로그램 실행 시 해당 함수들을 초기화한 후 그것을 이용하는 방법입니다.

  

- 명시적 링킹

  **프로그램이 실행 중일 때** `dll` 파일이 있는지 검사하고 동적으로 원하는 함수만 불러와서 쓰는 방법입니다.

현 게시글은 외부 라이브러리를 Import 하기 위한 내용임.

---

### 사용법

**명시적 링킹은** 설명한 그대로 직접 코드를 통해 원하는 함수만 불러와서 사용하는 방법입니다. 더 구체적으로 말하면 <u>함수 포인터를 얻어와서 사용하는 방법</u>입니다. 하지만 일반적인 오픈 소스에서는 이런 방식을 이용하지 않고 암시적 링킹을 통해 제공한다.

**암시적 링킹의** 방법을 통해 `dll` 파일을 생성할 경우 총 2개의 파일이 만들어지게 됩니다. 하나는 `*.dll`이고, 다른 하나는 `*.lib`입니다. 여기서 만들어진 `lib` 파일은 위에서 설명한 정적 라이브러리가 아니라 `dll`을 통해 불러들일 함수가 들어있습니다.

#### 필요한 것

1. `lib` 파일 (암시적 링킹에 의해서 생성된)
2. `include(header)` 파일
3. `dll` 파일

경로만 알려주면 compile은 성공, 실행은 실패. 해당 파일을 실행하기 위해선 exe 파일이 실행할 때 필요한 `dll` 파일을 연결해줘야 합니다. (해당 함수의 실체인 `dll`을 모르기때문에)

#### Compile

Compile 하기 위해선 `lib`파일과 `include(header)` 파일이 필요합니다.

[자체 동적 연결 라이브러리 만들기 및 사용, cpp](https://docs.microsoft.com/ko-kr/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp?view=vs-2017)

---

---

---

## [DLL의 기본](http://egloos.zum.com/sweeper/v/2991664)

### 프로세스 주소 공간

DLL 파일의 이미지는 실행 파일이나 다른 DLL이 DLL 내 포함되어 있는 함수를 호출하기 전에 반드시 **프로세스의 주소 공간에 매핑**되어 있어야 한다.

DLL 파일 이미지가 프로세스의 주소 공간에 매핑되고 나면, DLL이 가지고 있는 모든 함수들은 프로세스 내의 모든 쓰레드에 의해 호출될 수 있게 된다

> 쓰레드가 DLL에 포함되어 있는 함수를 호출하게 되면, 호출된 DLL 함수는 호출한 쓰레드의 스택으로부터 전달된 인자 값을 얻어내고,호출한 쓰레드의 스택을 이용하여 지역변수를 할당하게 된다. 뿐만 아니라 DLL 함수 내부에서 생성하는 모든 오브젝트들도 DLL 함수를 호출하는 쓰레드나 프로세스가 소유하게 되며, DLL 자체가 소유하는 오브젝트는 존재하지 않는다.

<u>DLL 고유의 특성은 거의 없어진다.</u>

+ BUT

**단일의 주소 공간은 하나의 실행 모듈과 다수의 DLL 모듈로 구성**되어 있음을 반드시 알아두어야 한다.

이 중 일부 모듈은 C/C++ 런타임 라이브러리를 정적으로 링크하고 있을 수도 있으며, 또 다른 모듈은 C/C++ 런타임 라이브러리를 동적으로 링크하고 있을 수도 있다.

따라서, **단일의 주소 공간 내에 C/C++ 런타임 라이브러리가 여러 번 로드될 수 있다**는 사실을 잊어버리면 곤란한다.

> 만약  C/C++ 런타임 라이브러리를 정적으로 링크하고 있다면, free 호출 과정에서 문제가 발생할 것이다.

+ 해결방법은

**DLL 내 메모리를 할당하는 함수가 있다면, 해제하는 함수도 DLL에 만들고 그걸 사용하는 것**이다.

```cpp
-- 실행 파일의 함수 --
void EXEFunc()
{
    // DLL 함수에서 할당한 메모리 블럭의 주소를 얻어온다.
    void* pv = DLLAllocFunc();
 
    // pv가 가리키는 메모리 블럭을 사용한다.
 
    // DLL 함수를 이용해 pv를 메모리로 반환한다.
    DLLFreeFunc(pv);
}
 
-- DLL의 할당 함수 --
void* DLLAllocFunc()
{
    // DLL의 C/C++ 런타임 힙으로부터 메모리를 할당받는다.
    return (malloc(100));
}
 
-- DLL의 해제 함수 --
void DLLFreeFunc(void* p)
{
    // DLL의 C/C++ 런타임 힙에서 메모리를 해제한다.
    free(p);
}
```



> [Stack and Heap](https://boycoding.tistory.com/235)
>
> 동적으로 할당된 변수가 삭제되면 메모리는 힙으로 "반환"되고, 이후 다시 할당될 수 있다. 포인터를 삭제하면 변수가 삭제되는 것이 아니라 관련 주소의 메모리를 운영 체제에 반환하는 것이다.
>
> 할당된 메모리는 명시적으로 할당 해제하거나 응용 프로그램이 종료될 때까지 유지된다. (메모리 릭 주의)

DLL은 변수, 함수, C++ 클래스를 다른 모듈에 export 할 수 있다.

