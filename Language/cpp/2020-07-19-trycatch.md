---
title: Exception Handling, Try cahtch
tag: cpp
---



[끝나지 않는 프로그래밍 일기-CPP](https://blog.hexabrain.net/179)

[모두의 코드](https://modoocode.com/230)

---

# 예외 처리

문법 상 틀린 것이 없는 코드 이지만, 실제로 실행해보면 오류가 발생하게 됩니다.

> 이렇게 정상적인 상황에서 벗어난 모든 예외적인 상황들을 **예외(exception)** 이라고 부릅니다.

If-else문으로 처리할 수 있지만 함수가 깊어질 수록 힘들게 됨.

연속적인 함수의 서클사이에서 각각의 함수에 해당하는 문제들을 확인하기 위해서는 각가의 함수들에서 처리결과를 모두 리턴해야 했지만 CPP은 이러한 문제를 해결함.

**예외 처리(Exception Handling)**에서 **예외(Exception)**이란 프로그램 실행 도중에 일어나는 비정상적인 상황을 의미합니다. 이런 상황이 벌어질때, 이를 처리하는 과정을 **예외 처리**라고 합니다.

---

##  throw

C++ 에서는 예외가 발생하였다는 사실을 명시적으로 나타낼 수 있습니다. 바로 `throw` 문을 사용하면 됩니다.

> [sizeof와 size_t](https://dojang.io/mod/page/view.php?id=787)
>
> 부호 없는 정수 자료형인데 sizeof 연산자나 offsetof 매크로의 결과.

C++ 에는 예외를 던지고 싶다면, **`throw` 로 예외로 전달하고 싶은 객체를 써주면 됩니다.** 

> 예외로 아무 객체나 던져도 상관 없지만, C++ 표준 라이브러리에는 이미 여러가지 종류의 예외들이 정의되어 있어서 이를 활용하는 것도 좋습니다. 예를 들어서, 위 경우 `out_of_range` 객체를 `throw` 합니다. C++ 표준에는 `out_of_range` 외에도 `overflow_error, length_error, runtime_error` 등등 여러가지가 정의되어 있고 표준 라이브러리에서 활용되고 있습니다.

이렇게 예외를 `throw` 하게 되면, `throw` 한 위치에서 즉시 함수가 종료되고, 예외 처리하는 부분까지 점프하게 됩니다. 따라서 `throw` 밑에 있는 모든 문장은 실행되지 않습니다.

---

## try-catch

발생한 예외를 어떻게 처리할까요?

```cpp
try  // 예외가 발생하는 영역
{
	if (예외 조건) throw 예외 객체; // 예외가 발생하면 예외를 던지는 영역
} 
catch (예외 객체) // 던져진 예외를 잡는 영역
{ 
	// 예외 처리 영역
}
```

예외가 발생할만한 영역을 try로 감싸주고, 

try 영역 내에서 예외 조건이 만족하면, throw로 그 예외를 던집니다. 

그러면 던져진 예외를 catch가 잡아 처리해줍니다. 

---

## stack unwinding, 스택 풀기

예외를 처리하는 영역이 없어 이 예외가 호출된 영역을 타고 계속 전달되는 현상

ex)

> func4() 호출 -> func3() 호출 -> func2() 호출 -> func1() 호출 
> -> func1 함수 내에서 예외 데이터 던짐 
> -> func2 함수가 예외 데이터를 받고 다시 func3 함수에 던짐 
> -> func3 함수가 예외 데이터를 받고 다시 func4 함수로 던짐 
> -> func4 함수가 예외 데이터를 받고 다시 main 함수 내에 있는 예외 처리 영역으로 던짐 
> -> 예외 처리

함수가 호출될 때는 저렇게 <u>각 함수의 스택 프레임이 생성됩니다.</u> 그리고, func1 함수에서 throw를 만나고, <u>자신과 자기를 호출한 함수의 스택을 모두 정리(해제)하고 돌아갑니다.</u> 이것이 **스택 풀기(Stack Unwinding)**입니다.

---

## 주의 사항

+ **생성자에서 예외가 발생 시에 소멸자가 호출되지 않음.** 

따라서, 만일 예외를 던지기 이전에 획득한 자원이 있다면 `catch` 에서 잘 해제시켜 줘야만 합니다.

```cpp
function()
{
	if(){}
	else if(){}
	else if(){}
}

int main()
{
	try{}
	catch(){}
	catch(){}
}
// switch 문 처럼 catch 역시 여러 종류의 throw 된 객체를 모두 받을 수 있습니다.
```

+ #### 기반 클래스와 파생 클래스의 경우 처리하는 방식

>  일반적으로 예외 객체는 `std::exception` 을 상속 받는 것이 좋다. 

왜냐하면 표준 라이브러리의 유용한 함수들(`nested_exception` 등) 을 사용할 수 있기 때문.

---

# noexcept, 예외를 발생시키지 않는 함수

만약에 어떤 함수가 예외를 발생시키지 않는다면 `noexcept` 를 통해 명시할 수 있습니다.

> 참고로, 함수에 `noexcept` 키워드를 붙였다고 해서, 실제로 함수가 예외를 절대로 던지지 않는다는 것은 아님.

대신 `noexcept` 로 명시된 함수가 예외를 발생시키게 된다면 예외가 제대로 처리되지 않고 프로그램이 종료됨.

> C++ 11 에서 부터 소멸자들은 기본적으로 `noexcept` 입니다. 절대로 소멸자에서 예외를 던지면 안됩니다.

