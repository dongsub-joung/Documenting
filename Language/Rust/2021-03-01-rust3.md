---
Title	: Rust (3), ownership
Tag: Rust
---


## 소유권

- 코드의 어느 부분이 힙의 어떤 데이터를 사용하는지 추적하는 것
- 힙의 중복된 데이터의 양을 최소화하는 것
- 그리고 힙 내에 사용하지 않는 데이터를 제거하여 공간이 모자라지 않게 하는 것
 모두 소유권과 관계된 문제들입니다. 

> 힙 데이터를 관리하는 것이 곧 소유권의 존재 이유임을 알게 되는 것은 이것이 어떤 방식으로 작동하는지 설명하는데 도움을 줄 수 있습니다.   

- - - -
### 규칙

1. 러스트의 각각의 값은 해당값의 오너라고 불리우는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재할 수 있다.
3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다.


> 소유권 규칙을 설명하기 위하여, 우리는 3장에서 다룬 바 있는 타입보다 더 복잡한 데이터 타입이 필요합니다.   
> 우리가 이전에 봐온 모든 데이터 타입들은 스택에 저장되었다가 스코프를 벗어날 때 스택으로부터 팝 됩니다만, 우리는 이제 힙에 저장되는 데이터를 관찰하고 러스트는 과연 어떻게 이 데이터를 비워내는지 설명할 필요가 있습니다.  


```rust
// case 1
let s= String::from("hello");

// case 2
let mut s= String::from("hello");
s.push_str(", world!");
println!("{}", s);
```

**이 타입은 힙에 할당되고 그런고로 컴파일 타임에는 우리가 알 수 없는 양의 텍스트를 저장할 수 있다.** 
- - - -
### 메모리와 할당

컴파일 타임에 크기를 알 수 없는 경우 및 실행 중 크기가 변할 수도 있는 경우의 텍스트 조각을 바이너리 파일에 집어넣을 수 없습니다.

String 타입은 변경 가능하고 커질 수 있는 텍스트를 지원하기 위해 만들어졌고, 우리는 힙에서 컴파일 타임에는 알 수 없는 어느 정도 크기의 메모리 공간을 할당받아 내용물을 저장할 필요가 있습니다. 
이는 즉 다음을 의미합니다
1. 런타임에 운영체제로부터 메모리가 요청되어야 한다.
2. String의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요하다.

#### 러스트는?

메모리는 변수가 소속되어 있는 스코프 밖으로 벗어나는 순간 자동으로 반납됩니다.

- `drop`함수 호출
String의 개발자가 메모리를 반환하도록 하는 코드를 집어넣을 수 있습니다. 러스트는 } 괄호가 닫힐때 자동적으로 drop을 호출합니다.

> C++: *Resource Acquisition Is Initialization, RAII*  

#### 변수와 데이터가 상호작용하는 방법: move
**String**
```rust
fn main() {
	let s1 = String::from("hello");
	let s2 = s1;
}
```

![](https://rinthel.github.io/rust-lang-book-ko/img/trpl04-01.svg)
![](https://rinthel.github.io/rust-lang-book-ko/img/trpl04-02.svg)

- 스택: string 메모리 주소 값, 길이, 용량
- 힙: string 메모리 값

**두번 해제 (double free) 오류에 관한 해결책**
할당된 메모리를 복사하는 것을 시도하는 대신, 러스트에서는 s1이 더이상 유효하지 않다고 간주하고, 그러므로 러스트는 s1가 스코프 밖으로 벗어났을 때 이무것도 해제할 필요가 없어집니다. 
= 기존 변수의 무력화
```
// 기존 변수를 사용,실행하면 발생하는 오류
> value used here after move
```

> 실제로 메모리 상 에서 일어난 일  
![](https://rinthel.github.io/rust-lang-book-ko/img/trpl04-04.svg)

#### 변수와 데이터가 상호작용하는 방법: 클론

```rust
// 클론으로 인한 비용은 각오해야함.
let s1= String::frome("hello");
let se2= s1.clone();

println!("s1= {}, s2= {}", s1, s2);
```

#### 스택에만 있는 데이터: 복사
정수형과 같이 컴파일 타임에 결정되어 있는 크기의 타입은 스택에 모두 저장되기 때문에, 실제 값의 복사본이 빠르게 만들어질 수 있다.
> Copy가 가능한 타입만으로 구성된 튜플들. (i32, i32)는 Copy가 되지만, (i32, String)은 안됩니다.  

- - - -
### 소유권과 함수
위와 동일, 함수의 매개변수로 값을 복사하는 메커니즘은 소유권 규칙에 따름.

### 반환 값과 스코프

만일 함수에게 값을 사용할 수 있도록 하되 소유권은 갖지 않도록 하고 싶다면요? 함수의 본체로부터 얻어진 결과와 더불어 우리가 넘겨주고자 하는 어떤 값을 다시 쓰고 싶어서 함께 반환받아야 한다면 꽤나 짜증나겠지요. 


