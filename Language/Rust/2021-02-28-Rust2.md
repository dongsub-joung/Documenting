---
Title: Rust (2)__data type
Tag: Rust
---

## shadowing

또 다른 mut과 shadowing의 차이는 let키워드를 다시 사용하여 효과적으로 새 변수를 선언하고, 값의 유형을 변경할 수 있으면서도 동일 이름을 사용할 수 있다는 점 입니다

```rust
let mut spaces = "   ";
spaces = spaces.len();
// 컴파일 에러
```

> 러스트의 변수가 불변성이기때문에 오는 특징  
> 상수 이외에 let을 이용한 변수를 새로 만들어서 할당하는 것이 가능하고   
> mut을 이용한 가용변수는 형변환에 있어서 제한이 있음.  


- - - -
## 데이터 타입들
### 스칼라
하나의 값으로 표현되는 타입입니다. 
- 정수형
- 부동소수점 숫자
- boolean
- 문자

- i: signed
- u: Unsigned
부호된 숫자는 2의 보수 형태를 사용하여 저장

> 확실하게 정해진 경우가 아니면 Rust의 기본 값인 i32가 일반적으로는 좋은 선택입니다. 이는 일반적으로 가장 빠르기 때문이죠. 심지어 64-bit 시스템에서도  

### 배열 
배열이 유용할 때는 당신의 데이터를 heap보다 stack에 할당하는 것을 원하거나, 당신이 항상 고정된 숫자의 요소를 갖는다고 확신하고 싶을 때
- 배열은 stack에 단일 메모리 뭉치로 할당됩니다.

> 많은 저수준 언어에서 이러한 타입의 검사는 수행되지 않으며 잘못된 색인을 제공하면 유효하지 않은 메모리에 액세스 할 수 있습니다. Rust는 메모리 접근을 허용하고 계속 진행하는 대신 즉시 종료하여 이러한 종류의 오류로부터 사용자를 보호합니다.   

- - - -
## 제어문
else if식의 사용은 당신의 코드를 이해하기 어렵게 하므로, 이런 경우를 위해 `match`라 불리는 강력한 분기 생성자가 존재.

If-else 구문 시 리턴 값에 대한 데이터타입이 컴파일 시에 보증되어야 함으로 데이터 타입은 동일한 반환값을 가져야함. = 구문으로 반환되는 값을 대입하는 변수에 대해서 데이터 타입을 명시(정의)해야주어야 함.


